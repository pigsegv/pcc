#pragma once

#ifndef PCC_PARSE_H
#define PCC_PARSE_H

#include "lexer.hpp"

#include <string>
#include <vector>
#include <stdint.h>

enum node_type {
  NODE_TYPE_PARSE_ERR,
  NODE_TYPE_BLOCK,
  NODE_TYPE_STMT,
  NODE_TYPE_EXPR,
  NODE_TYPE_DECL,
};

enum decl_type {
  DECL_TYPE_FUNC,
  DECL_TYPE_TYPEDEF,
  DECL_TYPE_RECORD,
  DECL_TYPE_FIELD,
  DECL_TYPE_ENUM,
  DECL_TYPE_PRIMITIVE,
};

enum types {
  DECL_TYPE_PTR,
  DECL_TYPE_ARRAY,

  TYPE_CHAR,
  TYPE_UCHAR,
  TYPE_SHORT,
  TYPE_USHORT,
  TYPE_INT,
  TYPE_UINT,
  TYPE_LONG,
  TYPE_ULONG,
  TYPE_LONGLONG,
  TYPE_ULONGLONG,
  TYPE_FLOAT,
  TYPE_DOUBLE,
  TYPE_LONGDOUBLE,
  TYPE_VOID,
};

enum record_type {
  RECORD_TYPE_STRUCT,
  RECORD_TYPE_UNION,
};

typedef int64_t record_ref;
typedef int64_t enum_ref;

struct ptr {
  struct type_spec *type;
  uint32_t level;
};

struct type_spec {
  enum types type;
  union {
    
  };
};

struct decl {
  enum decl_type type;
  std::string name;
  union {
    struct record_decl *record_decl;
  };
};

struct ast_node {
  enum node_type type;
  int64_t id;

  union {
    struct decl *decl;
  }

  struct ast_node *prev_sibling;
  struct ast_node *next_sibling;
  struct ast_node *child;
};

struct ast_node parse(const class lexer *lexer);

#endif // PCC_PARSE_H
